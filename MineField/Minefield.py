# -*- coding: utf-8 -*-
"""AI_Assignment2.ipynb

Automatically generated by Colaboratory.

"""

#!pip install python-sat
from Agent import * # See the Agent.py file
from pysat.solvers import Glucose3
from collections import deque

#!/usr/bin/env python3

#### All your code can go here.

safe = []       #contains those co-ords which are visited or have no mine
safe.append([3,0])  #starting position
unvisited = []  #unvisited neighbours
visited = []

ROW = 4
COL = 4

def _FindIndicesForLocation(loc):
        x,y = loc
        i,j = 4-y, x-1
        return i,j

class KB:
  def __init__(self):
    self.g = Glucose3()   # minus means no pit
    self.g.add_clause([-13])  #box 1 i.e. start doensn't have a pit
    self.g.add_clause([-4])   #final destination has no pit

  def tell(self, ag):
    percept = ag.PerceiveCurrentLocation()
    adj_rooms = ag._FindAdjacentRooms()         # room format is [1,1] [1,2] [1,3] [1,4]
    size = len(adj_rooms)

    if (percept == '=0'):
      for r in adj_rooms:
        x,y = _FindIndicesForLocation(r)
        value = x*4 + y + 1
        self.g.add_clause([-value])    #no pit

    elif (percept == '=1'):  
      temp_clause = []
      for i in range(size):
        x,y = _FindIndicesForLocation(adj_rooms[i])
        value = x*4 + y + 1
        temp_clause.append(value)

      self.g.add_clause(temp_clause)      # eg (1 v 2 v 3 v 4)

      if (size == 2):
        temp_clause[0] = -temp_clause[0]
        temp_clause[1] = -temp_clause[1]
        self.g.add_clause(temp_clause)

      elif (size == 3):
        one = []
        one.append(-temp_clause[0])
        one.append(-temp_clause[1])
        self.g.add_clause(one)

        two = []
        two.append(-temp_clause[0])
        two.append(-temp_clause[2])
        self.g.add_clause(two)

        three = []
        three.append(-temp_clause[1])
        three.append(-temp_clause[2])
        self.g.add_clause(three)

      else:
        one = []
        one.append(-temp_clause[0])
        one.append(-temp_clause[1])
        self.g.add_clause(one)

        two = []
        two.append(-temp_clause[0])
        two.append(-temp_clause[2])
        self.g.add_clause(two)

        three = []
        three.append(-temp_clause[0])
        three.append(-temp_clause[3])
        self.g.add_clause(three)

        four = []
        four.append(-temp_clause[1])
        four.append(-temp_clause[2])
        self.g.add_clause(four)

        five = []
        five.append(-temp_clause[1])
        five.append(-temp_clause[3])
        self.g.add_clause(five)

        six = []
        six.append(-temp_clause[2])
        six.append(-temp_clause[3])
        self.g.add_clause(six)

    elif (percept == '>1'):         #percept >1    
        temp_clause = []
        for i in range(size):
          x,y = _FindIndicesForLocation(adj_rooms[i])
          value = x*4 + y + 1
          temp_clause.append(value)

        if (size == 2):   #both have pits
          self.g.add_clause(temp_clause[0])
          self.g.add_clause(temp_clause[1])   
          
        elif (size == 3): 
          one = []
          one.append(temp_clause[0])
          one.append(temp_clause[1])
          self.g.add_clause(one)

          two = []
          two.append(temp_clause[0])
          two.append(temp_clause[2])
          self.g.add_clause(two)

          three = []
          three.append(temp_clause[1])
          three.append(temp_clause[2])
          self.g.add_clause(three)

        else : 
          one = []
          one.append(temp_clause[0])
          one.append(temp_clause[1])
          one.append(temp_clause[2])
          self.g.add_clause(one)

          two = []
          two.append(temp_clause[0])
          two.append(temp_clause[1])
          two.append(temp_clause[3])
          self.g.add_clause(two)

          three = []
          three.append(temp_clause[0])
          three.append(temp_clause[2])
          three.append(temp_clause[3])
          self.g.add_clause(three)

          four = []
          four.append(temp_clause[1])
          four.append(temp_clause[2])
          four.append(temp_clause[3])
          self.g.add_clause(four) 
          
    #update safe and unvisited
    for room in adj_rooms:
      x,y = _FindIndicesForLocation(room)
      cvt_room = [x,y]   #stores the real co-ords
      val = x*4 + y + 1

      if ((self.g.solve(assumptions=[val]) == False) and (cvt_room not in safe)):
        safe.append(cvt_room)

      if ((cvt_room not in visited) and (cvt_room not in unvisited)):
        unvisited.append(cvt_room)
      
  def ask(self, value):   #kb entails value
    if (self.g.solve(assumptions=[-value]) == False):
      return True
    else :
      return False

#to find intersection of 2 lists
def intersection(list1, list2):
    list3 = [value for value in list1 if value in list2]
    return list3

#to store matrix cell cordinates
class Coord:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
#node to be added in queue
class Node:
    def __init__(self, cell, dist, prev):
        self.cell = cell  # cell
        self.dist = dist  # distance of cell
        self.prev = prev  #pointer to previous
 

def isValid(row, col):
    if ((row < ROW) and (row >= 0) and (col < COL) and (col >= 0)):
      return True
    else:
      return False
 
col_num = [-1, 1, 0, 0]
row_num = [0, 0, 1, -1]

 
def BFS( src, dest, matrix):
     
    if ( matrix[dest.x][dest.y]!= 1 ) or ( matrix[src.x][src.y]!= 1 ):    # only '1' marked cells are allowed to be used
        return -1
     
    visit = []      #visit matrix to mark visited cells 

    for i in range(ROW):
      temp_row = []
      for j in range(COL):
        temp_row.append(False)
      visit.append(temp_row)
     
    visit[src.x][src.y] = True
     
    q = deque()  
    x = Node(src,0, None)
    q.append(x) 
     
    while (q):
        current = q.popleft() 
        cell = current.cell
        if cell.x == dest.x and cell.y == dest.y:
            return current
         
        for i in range(4):
            row = row_num[i] + cell.x
            col = col_num[i] + cell.y
             
            if (isValid(row,col)):
              if (matrix[row][col] == 1 and not visit[row][col]):
                visit[row][col] = True
                adjcell = Node(Coord(row,col), current.dist + 1, current)
                q.append(adjcell)
    #else
    return -1

#A and B are co-ordinates [x,y]
def Find_action(ag, A, B):
  if (A[1] == B[1]):
    if (A[0] < B[0]):
      ag.TakeAction('Down')
    else:
      ag.TakeAction('Up')

  elif (A[0] == B[0]):
    if (A[1] < B[1]):
      ag.TakeAction('Right')
    else:
      ag.TakeAction('Left')

# uses BFS to find shortest path
def Plan_route(ag, matrix, goals):

  src_x, src_y = _FindIndicesForLocation(ag.FindCurrentLocation())
  src = Coord(src_x, src_y)

  #help find the nearest destination to final goal
  helper = [[3,2,1,0],
            [4,3,2,1],
            [5,4,3,2],
            [6,5,4,3]]

  min_cost = 7
  dest_x = None
  dest_y = None

  for cell in goals:
    cost = helper[cell[0]][cell[1]]
    if (cost < min_cost):
      min_cost = cost
      dest_x = cell[0]
      dest_y = cell[1]

  dest = Coord(dest_x, dest_y)

  #marking that position as valid
  matrix[dest_x][dest_y] = 1

  #returns the destination node
  ans = BFS(src, dest, matrix)

  #remove from unvisited as its visited now
  unvisited.remove([dest_x, dest_y])

  path = []
  path_len = ans.dist
  
  #tracing the path
  for i in range(path_len+1):
     temp = []
     temp.append(ans.cell.x)
     temp.append(ans.cell.y)
     path.append(temp)
     ans = ans.prev

  path.reverse()
  for i in range(path_len):
    Find_action(ag, path[i], path[i+1])

def hybrid_agent():
  kb = KB()
  ag = Agent()
  
  matrix = [[0,0,0,0],
         [0,0,0,0],
         [0,0,0,0],
         [0,0,0,0]]

  print("Starting Location = ",ag.FindCurrentLocation())

  while (1):
    if (ag.FindCurrentLocation() == [4,4]):
      print("Game won!!\n")
      break

    x,y = _FindIndicesForLocation(ag.FindCurrentLocation())
   
    if ([x,y] not in visited):
      visited.append([x,y])   #append cur loc

    matrix[x][y] = 1  #current loc is valid  
    kb.tell(ag)   #perceive

    #updating safe
    for room in unvisited:
      val = 4*room[0] + room[1] + 1
      if ((kb.ask(-val) == True) and room not in safe):
        safe.append(room)

    goals = intersection(safe, unvisited)
    if ( len(goals) == 0):
      print("No safe path ahead is possible!")
      break

    #matrix gets modified in the func itself
    Plan_route(ag, matrix, goals)


#### You can change the main function as you wish. Run this program to see the output. Also see Agent.py code.

def main():
  hybrid_agent()

if __name__=='__main__':
    main()